// SPDX-License-Identifier: MIT
/**
 * Sistema de criação de arquivos de tipos
 * Cria tipos no diretório configurado (conventions.typesDirectory) com organização correta
 */

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { buildTypesFsPath } from '@core/config/conventions.js';
import type { ExistingType, TypeAnalysis } from '@';
import { toKebabCase } from './context-analyzer.js';

/**
 * Cria definição de tipo no diretório configurado (conventions.typesDirectory)
 */
export async function createTypeDefinition(analysis: TypeAnalysis, sourceFilePath: string): Promise<string> {
  const domain = extractDomain(sourceFilePath);
  const fileNome = toKebabCase(analysis.typeName);
  const typeCaminho = buildTypesFsPath(path.posix.join(domain, `${fileNome}.ts`));

  // Verificar se tipo já existe
  const existing = await findExistingType(analysis.typeName);
  if (existing) {
    // Retornar caminho do alias existente
    return `@types/types`; // Usar export centralizado
  }

  // Criar diretório se não existir
  const dir = path.dirname(typeCaminho);
  await fs.mkdir(dir, {
    recursive: true
  });

  // Gerar conteúdo do arquivo
  const content = generateTypeFileContent(analysis, sourceFilePath);

  // Escrever arquivo
  await fs.writeFile(typeCaminho, content, 'utf-8');

  // Adicionar export ao index.ts do domínio
  await addExportToIndex(domain, fileNome);

  // Retornar alias de import
  return `@types/types`;
}

/**
 * Busca tipo existente no diretório configurado (conventions.typesDirectory)
 */
export async function findExistingType(typeName: string): Promise<ExistingType | null> {
  try {
    const tiposDir = buildTypesFsPath('');
    const types = await scanTypesDirectory(tiposDir);
    for (const type of types) {
      if (type.name === typeName) {
        return type;
      }
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Verifica se dois tipos são iguais
 */
export function isSameType(type1: ExistingType, type2: string): boolean {
  // Simplificado - em produção, usar parser para comparação estrutural
  const normalize = (str: string) => str.replace(/\s+/g, ' ').trim();
  return normalize(type1.definition) === normalize(type2);
}

/**
 * Gera conteúdo do arquivo de tipo
 */
function generateTypeFileContent(analysis: TypeAnalysis, sourceFilePath: string): string {
  const date = new Date().toISOString();
  return `// SPDX-License-Identifier: MIT
/**
 * Tipo gerado automaticamente
 * Origem: ${sourceFilePath}
 * Confiança: ${analysis.confidence}%
 * Data: ${date}
 *
 * @generated by doutor fix-any-to-proper-type
 */

${analysis.typeDefinition}
`;
}

/**
 * Adiciona export ao index.ts do domínio
 */
async function addExportToIndex(domain: string, fileNome: string): Promise<void> {
  const indexCaminho = buildTypesFsPath(path.posix.join(domain, 'index.ts'));
  try {
    // Verificar se arquivo index.ts existe
    await fs.access(indexCaminho);

    // Ler conteúdo atual
    const content = await fs.readFile(indexCaminho, 'utf-8');

    // Verificar se export já existe
    const exportStatement = `export * from './${fileNome}.js';`;
    if (content.includes(exportStatement)) {
      return; // Já existe
    }

    // Adicionar export
    await fs.appendFile(indexCaminho, `${exportStatement}\n`, 'utf-8');
  } catch {
    // Criar index.ts se não existir
    const header = `// SPDX-License-Identifier: MIT
/**
 * Exports do domínio ${domain}
 */

`;
    const exportStatement = `export * from './${fileNome}.js';\n`;
    await fs.writeFile(indexCaminho, header + exportStatement, 'utf-8');
  }
}

/**
 * Extrai domínio do caminho do arquivo
 */
function extractDomain(fileCaminho: string): string {
  const match = fileCaminho.match(/src[\\/]([\w-]+)[\\/]/);
  return match ? match[1] : 'shared';
}

/**
 * Escaneia diretório de tipos
 */
async function scanTypesDirectory(dir: string): Promise<ExistingType[]> {
  const types: ExistingType[] = [];
  try {
    const entries = await fs.readdir(dir, {
      withFileTypes: true
    });
    for (const entry of entries) {
      const fullCaminho = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        // Recursivo
        const subTipos = await scanTypesDirectory(fullCaminho);
        types.push(...subTipos);
      } else if (entry.name.endsWith('.ts') && entry.name !== 'index.ts') {
        // Ler arquivo e extrair tipos
        const content = await fs.readFile(fullCaminho, 'utf-8');
        const extractedTipos = extractTypesFromFile(content, fullCaminho);
        types.push(...extractedTipos);
      }
    }
  } catch {
    // Ignorar erros
  }
  return types;
}

/**
 * Extrai tipos de um arquivo
 */
function extractTypesFromFile(content: string, fileCaminho: string): ExistingType[] {
  const types: ExistingType[] = [];

  // Regex simples para encontrar interfaces e types exportados
  const interfaceRegex = /export\s+interface\s+(\w+)\s*{([^}]*)}/g;
  const typeRegex = /export\s+type\s+(\w+)\s*=\s*([^;]+);/g;
  let match;

  // Interfaces
  while ((match = interfaceRegex.exec(content)) !== null) {
    types.push({
      name: match[1],
      path: fileCaminho,
      definition: match[0],
      isExported: true,
      domain: extractDomain(fileCaminho)
    });
  }

  // Types
  while ((match = typeRegex.exec(content)) !== null) {
    types.push({
      name: match[1],
      path: fileCaminho,
      definition: match[0],
      isExported: true,
      domain: extractDomain(fileCaminho)
    });
  }
  return types;
}